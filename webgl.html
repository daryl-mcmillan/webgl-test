<html>
<head>
<title>test</title>
</head>

<body>
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/230211/glmatrix.min.js"></script>
<script id="fragment" type="x-shader/x-fragment">
    precision lowp float;

	varying lowp vec3 vColor;

	void main(void) {
		gl_FragColor = vec4(vColor, 1.0);
	}
</script>

<script id="vertex" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexTest;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform float time;

	varying lowp vec3 vColor;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0) + vec4(time * 0.001,0,0,0);
		vColor = aVertexTest * time * 0.001;
	}
</script>

<canvas id="view" style="border: none;" width="300" height="300"></canvas>

<script>

	function initGL(canvas) {
		var gl = canvas.getContext("webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		return gl;
	}

	function getShader(gl, scriptId) {

		const shaderTypes = {
			"x-shader/x-fragment": gl.FRAGMENT_SHADER,
			"x-shader/x-vertex": gl.VERTEX_SHADER
		};

		var shaderScript = document.getElementById(scriptId);
		if (!shaderScript) {
			throw new Error( "no shader script with id: " + scriptId );
		}

		var script = "";
		var node = shaderScript.firstChild;
		do {
			script += node.textContent
		} while( node = node.nextSibling )

		var shader = gl.createShader( shaderTypes[ shaderScript.type ] );
		gl.shaderSource(shader, script);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			throw new Error( "error in shader: " + scriptId + "\n" + gl.getShaderInfoLog(shader) );
		}

		return shader;
	}

	function initShaders(gl) {
		var fragmentShader = getShader(gl, "fragment");
		var vertexShader = getShader(gl, "vertex");

		var shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			throw new Error("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		shaderProgram.vertexTestAttribute = gl.getAttribLocation(shaderProgram, "aVertexTest");
		gl.enableVertexAttribArray(shaderProgram.vertexTestAttribute);

		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.timeUniform = gl.getUniformLocation(shaderProgram, "time" );
		return shaderProgram;
	}

	var triangleVertexPositionBuffer;
	var squareVertexPositionBuffer;

	function initBuffers(gl) {
		triangleVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
		var vertices = [
			 0.0,  1.0,  0.0,          1, 0, 0,
			-1.0, -1.0,  0.0,          0, 0, 1,
			 1.0, -1.0,  0.0,          0, 1, 0,
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		triangleVertexPositionBuffer.itemSize = 3;
		triangleVertexPositionBuffer.numItems = 3;

		squareVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		vertices = [
			 1.0,  1.0,  0.0, 1,0,0,
			-1.0,  1.0,  0.0, 0,0,1,
			 1.0, -1.0,  0.0, 0,1,0,
			-1.0, -1.0,  0.0, 1,0,1
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		squareVertexPositionBuffer.itemSize = 3;
		squareVertexPositionBuffer.numItems = 4;
	}

	function drawScene(gl, shaderProgram, timestamp) {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		// set current time
		gl.uniform1f(shaderProgram.timeUniform, timestamp);

		// set up a projection matrix
		var pMatrix = mat4.create();
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);

		var mvMatrix = mat4.create();
		mat4.identity(mvMatrix);

		mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(shaderProgram.vertexTestAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 24, 12);
		gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);

		mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(shaderProgram.vertexTestAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 24, 12);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
	}

	function animate( drawFunc ) {
		var initialTime = 0;
		var repeat = function( timestamp ) {
			drawFunc( timestamp - initialTime );
			requestAnimationFrame( repeat );
		};
		requestAnimationFrame( ( timestamp ) => {
			drawFunc( 0 );
			initialTime = timestamp;
			requestAnimationFrame( repeat );
		} );
	}

	function webGLStart() {
		var canvas = document.getElementById("view");
		var gl = initGL(canvas);
		var shaderProgram = initShaders(gl);
		initBuffers(gl);

		gl.clearColor(1.0, 1.0, 1.0, 1.0);
		gl.enable(gl.DEPTH_TEST);
		
		animate( timestamp => {
			drawScene(gl, shaderProgram, timestamp);
		} );
	}

	webGLStart()
</script>
</body>
</html>