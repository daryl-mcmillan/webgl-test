<html>
<head>
<title>test</title>
</head>

<body>
<script src="http://evanw.github.com/lightgl.js/lightgl.js"></script>

<img src="DATA:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAtSURBVDhPY/iPCt7KqKAhqAQMDAsNaNIE0cjUAA0tGECTBiKoBAwMfQ3//wMAGtniUB6clGEAAAAASUVORK5CYII=" id="icon" hidden />
<canvas id="view" style="border: none;" width="1000" height="800"></canvas>

<script>

	function fullscreen(gl, canvas) {
		document.body.style.padding = "0px";
		document.body.style.margin = "0px";
		document.body.style.overflow = "hidden";
		canvas.style.position = "absolute";
		canvas.style.border = "none";
		canvas.style.left = "0px;"
		canvas.style.top = "0px;"
		const resize = function() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			gl.viewportWidth = canvas.width;
			gl.viewportHeight = canvas.height;
		};
		resize();
		window.addEventListener('resize', resize);
	}

	function glHelper( canvas ) {
		const gl = canvas.getContext( "webgl" );
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		return {
			gl : gl,
			createShader: function( type, script ) {
				const shader = gl.createShader( type );
				gl.shaderSource( shader, script );
				gl.compileShader( shader );
				if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
					throw new Error( "error in shader: " + gl.getShaderInfoLog( shader ) );
				}
				return shader;
			},
			createProgram: function( shaders ) {
				const shaderProgram = gl.createProgram();
				for( const shader of shaders ) {
					gl.attachShader( shaderProgram, shader );
				}
				gl.linkProgram( shaderProgram );
				if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
					throw new Error( "Could not initialise shaders" );
				}
				return {
					program: shaderProgram,
					use: function() {
						gl.useProgram( shaderProgram );
					},
          getAttribLocation: function( name ) {
						return gl.getAttribLocation( shaderProgram, name );
					},
					getUniformLocation: function( name ) {
						return gl.getUniformLocation( shaderProgram, name );
					}
				};
			}
		};
	}

	function initBuffers(gl) {
		const buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		vertices = [];
		var count = 0;
		
		for( var i=0; i<100000; i++ ) {
			// start
			vertices.push(
				-2.0 - Math.random(),
				Math.random() * 4.0 - 2.0
			);
			// end
			vertices.push(
				2.0 + Math.random(),
				Math.random() * 4.0 - 2.0
			);
			// startT
			vertices.push( 0.25 );
			// deltaT
			vertices.push( 5.0 );
			count += 1;
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
		const recordSize = 6 * 4;
		buffer.draw = function( shader ) {
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.vertexAttribPointer(shader.getAttribLocation("aVertexStart"), 2, gl.FLOAT, false, recordSize, 0);
			gl.vertexAttribPointer(shader.getAttribLocation("aVertexEnd"), 2, gl.FLOAT, false, recordSize, 4 * 2);
			gl.vertexAttribPointer(shader.getAttribLocation("aStartT"), 1, gl.FLOAT, false, recordSize, 4 * 4);
			gl.vertexAttribPointer(shader.getAttribLocation("aDeltaT"), 1, gl.FLOAT, false, recordSize, 4 * 5);
			gl.drawArrays(gl.POINTS, 0, count);
		};
		return buffer;
	}

	function loadTexture(gl, data) {
		const index = 0;
		const glTexture = gl.createTexture();
		gl.activeTexture(gl.TEXTURE0 + index);
		gl.bindTexture(gl.TEXTURE_2D, glTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
		gl.generateMipmap(gl.TEXTURE_2D);
		return index;
	}

	function drawScene(gl, shaderProgram, buffer, timestamp, texture) {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		shaderProgram.use();

		// set current time
		gl.uniform1f(shaderProgram.getUniformLocation("uTime"), timestamp/1000);
		// set current texture
		gl.uniform1i(shaderProgram.getUniformLocation("texture"), texture);

		// set up a projection matrix
		const pMatrix = GL.Matrix.perspective( 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0 ).transpose();
		gl.uniformMatrix4fv(shaderProgram.getUniformLocation("uPMatrix"), false, pMatrix.m);

		const mvMatrix = GL.Matrix.translate( 0, 0, -7 ).transpose();
		gl.uniformMatrix4fv(shaderProgram.getUniformLocation("uMVMatrix"), false, mvMatrix.m);

		buffer.draw( shaderProgram );
	}

	function animate( drawFunc ) {
		var initialTime = 0;
		var repeat = function( timestamp ) {
			drawFunc( timestamp - initialTime );
			requestAnimationFrame( repeat );
		};
		requestAnimationFrame( ( timestamp ) => {
			drawFunc( 0 );
			initialTime = timestamp;
			requestAnimationFrame( repeat );
		} );
	}

	function webGLStart() {
		var canvas = document.getElementById("view");
		var helper = glHelper( canvas );
		fullscreen(helper.gl, canvas);

		const shaderProgram = helper.createProgram([
			helper.createShader( helper.gl.VERTEX_SHADER, `
				attribute vec2 aVertexStart;
				attribute vec2 aVertexEnd;
				attribute float aStartT;
				attribute float aDeltaT;

				uniform mat4 uMVMatrix;
				uniform mat4 uPMatrix;
				uniform float uTime;

				varying lowp vec3 vColor;

				void main(void) {
					float progress = clamp( ( uTime - aStartT ) / aDeltaT, 0.0, 1.0 );
					vec2 position = mix( aVertexStart, aVertexEnd, progress );
					gl_Position = uPMatrix * uMVMatrix * vec4( position, 0.0, 1.0 );
					gl_PointSize = 10.0 / gl_Position.w * aStartT;
					vColor = vec3(1, 0, 0);
				}
			`),
			helper.createShader( helper.gl.FRAGMENT_SHADER, `
				precision lowp float;
				uniform sampler2D texture;

				varying lowp vec3 vColor;

				void main(void) {
					//gl_FragColor = texture2D(texture, gl_PointCoord);
					gl_FragColor = vec4(vColor, 1.0);
				}
			`)
		]);

		helper.gl.enableVertexAttribArray(shaderProgram.getAttribLocation("aVertexStart"));
		helper.gl.enableVertexAttribArray(shaderProgram.getAttribLocation("aVertexEnd"));
		helper.gl.enableVertexAttribArray(shaderProgram.getAttribLocation("aStartT"));
		helper.gl.enableVertexAttribArray(shaderProgram.getAttribLocation("aDeltaT"));

		const buffer = initBuffers(helper.gl);

		const icon = document.getElementById('icon');  // get the <img> tag
		const texture = loadTexture(helper.gl, icon);

		helper.gl.clearColor(1.0, 1.0, 1.0, 1.0);
		helper.gl.enable(helper.gl.DEPTH_TEST);
		helper.gl.enable(helper.gl.CULL_FACE);
		helper.gl.cullFace(helper.gl.BACK);

		animate( timestamp => {
			drawScene(helper.gl, shaderProgram, buffer, timestamp, texture);
		} );
	}

	webGLStart()
</script>
</body>
</html>
