<html>
<head>
<title>test</title>
</head>

<body>
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/230211/glmatrix.min.js"></script>
<script src="http://evanw.github.com/lightgl.js/lightgl.js"></script>

<canvas id="view" style="border: none;" width="1000" height="800"></canvas>

<script>

	function glHelper( canvas ) {
		const gl = canvas.getContext( "webgl" );
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		return {
			gl : gl,
			createShader: function( type, script ) {
				const shader = gl.createShader( type );
				gl.shaderSource( shader, script );
				gl.compileShader( shader );
				if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
					throw new Error( "error in shader: " + gl.getShaderInfoLog( shader ) );
				}
				return shader;
			},
			createProgram: function( shaders ) {
				const shaderProgram = gl.createProgram();
				for( const shader of shaders ) {
					gl.attachShader( shaderProgram, shader );
				}
				gl.linkProgram( shaderProgram );
				if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
					throw new Error( "Could not initialise shaders" );
				}
				const attributes = {};
				const attributeCount = gl.getProgramParameter( shaderProgram, gl.ACTIVE_ATTRIBUTES );
				for( var i = 0; i < attributeCount; i++ ) {
					const attribute = gl.getActiveAttrib( shaderProgram, i );
					const location = gl.getAttribLocation( shaderProgram, attribute.name );
					attributes[attribute.name] = {
						location: location,
						enable: function() {
							gl.enableVertexAttribArray(location);
						}
					};
					console.log( attribute );
				}
				const uniformCount = gl.getProgramParameter( shaderProgram, gl.ACTIVE_UNIFORMS );
				for( var i = 0; i < uniformCount; i++ ) {
					const uniform = gl.getActiveUniform( shaderProgram, i );
					uniform.location = gl.getUniformLocation( shaderProgram, uniform.name );
					console.log( uniform );
				}
				return {
					program: shaderProgram
				};
			}
		};
	}

	var triangleVertexPositionBuffer;
	var squareVertexPositionBuffer;

	function initBuffers(gl) {
		triangleVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
		var vertices = [
			 0.0,  1.0,  0.0,    0.01, 0, 0, 0,
			-1.0, -1.0,  0.0,    0.01, 0, 0, 0,
			 1.0, -1.0,  0.0,    0.01, 0, 0, 0,
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		triangleVertexPositionBuffer.itemSize = 3;
		triangleVertexPositionBuffer.numItems = 3;

		squareVertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		vertices = [
			 1.0,  1.0,  0.0,    0,0.01,0, 0,
			-1.0,  1.0,  0.0,    0,0.01,0, 0,
			 1.0, -1.0,  0.0,    0,0.01,0, 0,
			-1.0, -1.0,  0.0,    0,0.01,0, 0,
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		squareVertexPositionBuffer.itemSize = 3;
		squareVertexPositionBuffer.numItems = 4;
	}

	function drawScene(gl, shaderProgram, timestamp) {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		// set current time
		gl.uniform1f(shaderProgram.timeUniform, timestamp);

		// set up a projection matrix
		const pMatrix = GL.Matrix.perspective( 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0 ).transpose();
		gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix.m);

		var mvMatrix = GL.Matrix.identity();
		
		mvMatrix = mvMatrix.multiply( GL.Matrix.translate(-1.5, 0.0, -7.0) );
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix.transpose().m);
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 0);
		gl.vertexAttribPointer(shaderProgram.vertexVelocityAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 4 * 3);
		gl.vertexAttribPointer(shaderProgram.startTimeAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 4 * 6);
		gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);

		mvMatrix = mvMatrix.multiply( GL.Matrix.translate(3.0, 0.0, 0.0) );
		gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix.transpose().m);
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 0);
		gl.vertexAttribPointer(shaderProgram.vertexVelocityAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 4 * 3);
		gl.vertexAttribPointer(shaderProgram.startTimeAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 4 * 7, 4 * 6);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
	}

	function animate( drawFunc ) {
		var initialTime = 0;
		var repeat = function( timestamp ) {
			drawFunc( timestamp - initialTime );
			requestAnimationFrame( repeat );
		};
		requestAnimationFrame( ( timestamp ) => {
			drawFunc( 0 );
			initialTime = timestamp;
			requestAnimationFrame( repeat );
		} );
	}

	function webGLStart() {
		var canvas = document.getElementById("view");
		var helper = glHelper( canvas );
		const shaderProgram = helper.createProgram([
			helper.createShader( helper.gl.VERTEX_SHADER, `
				attribute vec3 aVertexPosition;
				attribute vec3 aVertexVelocity;
				attribute float aStartTime;

				uniform mat4 uMVMatrix;
				uniform mat4 uPMatrix;
				uniform float uTime;

				varying lowp vec3 vColor;

				void main(void) {
					gl_Position = uPMatrix * uMVMatrix * ( vec4(aVertexPosition, 1.0) + vec4( (uTime-aStartTime) * aVertexVelocity, 0.0 ) );
					vColor = vec3(1, 0, 0);
				}
			`),
			helper.createShader( helper.gl.FRAGMENT_SHADER, `
				precision lowp float;

				varying lowp vec3 vColor;

				void main(void) {
					gl_FragColor = vec4(vColor, 1.0);
				}
			`)
		]);
		helper.gl.useProgram(shaderProgram.program);
		shaderProgram.program.vertexPositionAttribute = helper.gl.getAttribLocation(shaderProgram.program, "aVertexPosition");
		helper.gl.enableVertexAttribArray(shaderProgram.program.vertexPositionAttribute);
		shaderProgram.program.vertexVelocityAttribute = helper.gl.getAttribLocation(shaderProgram.program, "aVertexVelocity");
		helper.gl.enableVertexAttribArray(shaderProgram.program.vertexVelocityAttribute);
		shaderProgram.program.startTimeAttribute = helper.gl.getAttribLocation(shaderProgram.program, "aStartTime");
		helper.gl.enableVertexAttribArray(shaderProgram.program.startTimeAttribute);

		shaderProgram.program.pMatrixUniform = helper.gl.getUniformLocation(shaderProgram.program, "uPMatrix");
		shaderProgram.program.mvMatrixUniform = helper.gl.getUniformLocation(shaderProgram.program, "uMVMatrix");
		shaderProgram.program.timeUniform = helper.gl.getUniformLocation(shaderProgram.program, "uTime" );

		initBuffers(helper.gl);

		helper.gl.clearColor(1.0, 1.0, 1.0, 1.0);
		helper.gl.enable(helper.gl.DEPTH_TEST);
		
		animate( timestamp => {
			drawScene(helper.gl, shaderProgram.program, timestamp);
		} );
	}

	webGLStart()
</script>
</body>
</html>