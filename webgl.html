<html>
<head>
<title>test</title>
</head>

<body>
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/230211/glmatrix.min.js"></script>
<script src="http://evanw.github.com/lightgl.js/lightgl.js"></script>

<canvas id="view" style="border: none;" width="1000" height="800"></canvas>

<script>

	function glHelper( canvas ) {
		const gl = canvas.getContext( "webgl" );
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		return {
			gl : gl,
			createShader: function( type, script ) {
				const shader = gl.createShader( type );
				gl.shaderSource( shader, script );
				gl.compileShader( shader );
				if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
					throw new Error( "error in shader: " + gl.getShaderInfoLog( shader ) );
				}
				return shader;
			},
			createProgram: function( shaders ) {
				const shaderProgram = gl.createProgram();
				for( const shader of shaders ) {
					gl.attachShader( shaderProgram, shader );
				}
				gl.linkProgram( shaderProgram );
				if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
					throw new Error( "Could not initialise shaders" );
				}
				const attributes = {};
				const attributeCount = gl.getProgramParameter( shaderProgram, gl.ACTIVE_ATTRIBUTES );
				for( var i = 0; i < attributeCount; i++ ) {
					const attribute = gl.getActiveAttrib( shaderProgram, i );
					const location = gl.getAttribLocation( shaderProgram, attribute.name );
					attributes[attribute.name] = {
						location: location,
						enable: function() {
							gl.enableVertexAttribArray(location);
						}
					};
				}
				const uniformCount = gl.getProgramParameter( shaderProgram, gl.ACTIVE_UNIFORMS );
				const uniforms = {};
				for( var i = 0; i < uniformCount; i++ ) {
					const uniform = gl.getActiveUniform( shaderProgram, i );
					const location = gl.getUniformLocation( shaderProgram, uniform.name );
					uniforms[uniform.name] = {
						location: location
					};
				}
				return {
					program: shaderProgram,
					attributes: attributes,
					uniforms: uniforms,
					use: function() {
						gl.useProgram( shaderProgram );
					}
				};
			}
		};
	}

	var vertexPositionBuffer;

	function initBuffers(gl) {
		vertexPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
		vertices = [];
		var count = 0;
		
		for( var i=0; i<1000000; i++ ) {
			var x = 0;
			var y = 0;
			var v = ( Math.random() ) * 0.001 + 0.0005;
			var theta = Math.random() * 2 * Math.PI;
			var latitude = Math.random() * 2.0 - 1.0;
			var vx = Math.sqrt( 1 - latitude * latitude ) * Math.cos( theta ) * v;
			var vy = Math.sqrt( 1 - latitude * latitude ) * Math.sin( theta ) * v;
			var vz = latitude * v;

			vertices.push( x, y, 0 );
			vertices.push( vx, vy, vz );
			vertices.push( 0 );

			vertices.push( x, y+0.01, 0 );
			vertices.push( vx, vy, vz );
			vertices.push( 0 );

			vertices.push( x+0.01, y, 0 );
			vertices.push( vx, vy, vz );
			vertices.push( 0 );
			count += 3;
		}
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		vertexPositionBuffer.numItems = count;
		vertexPositionBuffer.drawType = gl.TRIANGLES;
	}
	
	function drawScene(gl, shaderProgram, timestamp) {
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		shaderProgram.use();

		// set current time
		gl.uniform1f(shaderProgram.uniforms.uTime.location, timestamp);

		// set up a projection matrix
		const pMatrix = GL.Matrix.perspective( 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0 ).transpose();
		gl.uniformMatrix4fv(shaderProgram.uniforms.uPMatrix.location, false, pMatrix.m);

		var mvMatrix = GL.Matrix.translate(0.0, 0.0, -7.0);
		gl.uniformMatrix4fv(shaderProgram.uniforms.uMVMatrix.location, false, mvMatrix.transpose().m);

		gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.attributes.aVertexPosition.location, 3, gl.FLOAT, false, 4 * 7, 0);
		gl.vertexAttribPointer(shaderProgram.attributes.aVertexVelocity.location, 3, gl.FLOAT, false, 4 * 7, 4 * 3);
		gl.vertexAttribPointer(shaderProgram.attributes.aStartTime.location, 1, gl.FLOAT, false, 4 * 7, 4 * 6);
		gl.drawArrays(vertexPositionBuffer.drawType, 0, vertexPositionBuffer.numItems);
	}

	function animate( drawFunc ) {
		var initialTime = 0;
		var repeat = function( timestamp ) {
			drawFunc( timestamp - initialTime );
			requestAnimationFrame( repeat );
		};
		requestAnimationFrame( ( timestamp ) => {
			drawFunc( 0 );
			initialTime = timestamp;
			requestAnimationFrame( repeat );
		} );
	}

	function webGLStart() {
		var canvas = document.getElementById("view");
		var helper = glHelper( canvas );

		const shaderProgram = helper.createProgram([
			helper.createShader( helper.gl.VERTEX_SHADER, `
				attribute vec3 aVertexPosition;
				attribute vec3 aVertexVelocity;
				attribute float aStartTime;

				uniform mat4 uMVMatrix;
				uniform mat4 uPMatrix;
				uniform float uTime;

				varying lowp vec3 vColor;

				void main(void) {
					gl_Position = uPMatrix * uMVMatrix * ( vec4(aVertexPosition, 1.0) + vec4( (uTime-aStartTime) * aVertexVelocity, 0.0 ) );
					vColor = vec3(1, 0, 0);
				}
			`),
			helper.createShader( helper.gl.FRAGMENT_SHADER, `
				precision lowp float;

				varying lowp vec3 vColor;

				void main(void) {
					gl_FragColor = vec4(vColor, 1.0);
				}
			`)
		]);

		shaderProgram.attributes.aVertexPosition.enable();
		shaderProgram.attributes.aVertexVelocity.enable();
		shaderProgram.attributes.aStartTime.enable();

		initBuffers(helper.gl);

		helper.gl.clearColor(1.0, 1.0, 1.0, 1.0);
		helper.gl.enable(helper.gl.DEPTH_TEST);

		animate( timestamp => {
			drawScene(helper.gl, shaderProgram, timestamp);
		} );
	}

	webGLStart()
</script>
</body>
</html>